# Intro

Component classes in jsx6 have a template method `tpl()` where template for the component is initialized. Our example is taken from one such component. There we use component state object that is: `this.$s`. 

```js
tpl(){
	let {$s} = this
	$s.mode = 'preview'
	// ....
}
```

The `$s` is an instance of a proxy that:

- creates a signal on property access if it already does not exist
- returns existing signal if already initialized

## The goal

In our example value for mode can be `edit|preview` and based on that we will highlight one of two buttons, and also show/hide one of two components to match.

Focus of this document is code that is needed to show/hide  the `previewField `based on value of `$s.mode` signal.

## A bit about working with signals in jsx6 

In a component you can create signals by just accessing properties on the `this.$s` state object.

```js
// use destructuring to declare local variable $s
let {$s} = this 
// proxy will create a signal with that initial value
$s.mode = 'preview' 
//$s.mode is a function, and to get the value you need to call it
console.log('mode', $s.mode())
```

You can use the value like this to hide an element initially. It will evaluate immediately and will not be updated when signal value changes. This is only useful in some cases.

```js
let div1 = <div hidden={$s.mode() !== 'edit'}>edit</div>
```

You can give reference to a signal as the attribute value. This way attribute will change when signal changes, and will match the value form the signal.

```js
let div2 = <div hidden={$s.mode}>edit</div>
```
This is not what we need here.


## Giving derived value to attribute based on a signal

If we just give reference to signal `$s.mode` as value for `hidden` attribute it will reflect the value of `$s.mode` but will not be what we need. 

In the library we have a `$S` utility that can provide new signals based on a transform function and one or more signals to pull values from. The new signal will change value when any of dependent signals change and new value will be generated by calling the transform function.

```js
let transform = mode=>mode !== 'preview'
<div p='previewField' hidden={$S(transform,$s.mode)}>P</div>
// or inline
<div p='previewField' hidden={$S(mode=>mode !== 'preview',$s.mode)}>P</div>
```

This is verbose so we can use `NEQ` utility that generates a transform function based on provided value

```js
<div p='previewField' hidden={$S(NEQ('preview'),$s.mode)}>P</div>
```

There is also a variant `$NEQ` that does not create transform function, but instead creates a signal based on value and another signal.
```js
<div p='previewField' hidden={$NEQ('preview',$s.mode)}>P</div>
```

## final result

And as sugar on top of all of this , there is a special attribute `x-if` that can be used to avoid extra negation and ofc a signal generator `$EQ`

```js
<div p='previewField' x-if={$EQ('preview',$s.mode)}>P</div>
```

